require('dotenv').config();
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const QRCode = require('qrcode');
const nodemailer = require('nodemailer');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');

const app = express();
const PORT = process.env.PORT || 10000;
const JWT_SECRET = process.env.JWT_SECRET || 'campuseats_secret_key_2024';

app.use(cors({
  origin: '*',  // Autorise tous les domaines
  credentials: true
}));

app.use(helmet());
app.use(morgan('combined'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const db = {
  users: [
    {
      id: 1,
      email: 'marie.dupont@univ.fr',
      password: '$2b$10$8K1p/a0dclxKOktjNhDYzeUslkh1Oa4VEFLfgOQU9jzb85bZtdCve',
      name: 'Marie Dupont',
      campus: 'Universit√© Paris-Saclay',
      year: 'L3 Informatique',
      loyaltyPoints: 127,
      totalOrders: 47,
      createdAt: new Date()
    }
  ],
  restaurants: [
    {
      id: 1,
      name: 'Pizzeria Campus',
      description: 'Pizzas italiennes ‚Ä¢ P√¢tes ‚Ä¢ Salades',
      image: 'üçï',
      rating: 4.7,
      prepTime: '8-12 min',
      isOpen: true,
      // HASH CORRIG√â pour "password123"
      email: 'pizzeria@campus.fr',
      password: '$2b$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password123
      menu: [
        { id: 1, name: 'Pizza Margherita', description: 'Tomates, mozzarella, basilic', price: 12.50, category: 'Pizza', image: 'üçï' },
        { id: 2, name: 'P√¢tes Carbonara', description: 'P√¢tes fra√Æches, lardons, parmesan', price: 9.80, category: 'P√¢tes', image: 'üçù' },
        { id: 3, name: 'Salade C√©sar', description: 'Salade, poulet, cro√ªtons, parmesan', price: 8.50, category: 'Salade', image: 'ü•ó' },
        { id: 4, name: 'Coca-Cola', description: '33cl', price: 2.50, category: 'Boisson', image: 'ü•§' }
      ]
    },
    {
      id: 2,
      name: 'Green & Fresh',
      description: 'Salades ‚Ä¢ Bowls ‚Ä¢ Smoothies',
      image: 'ü•ó',
      rating: 4.9,
      prepTime: '5-8 min',
      isOpen: true,
      // HASH CORRIG√â pour "password123"
      email: 'green@campus.fr',
      password: '$2b$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', // password123
      menu: [
        { id: 5, name: 'Bowl Healthy', description: 'Quinoa, avocat, l√©gumes de saison', price: 11.90, category: 'Bowl', image: 'ü•ó' },
        { id: 6, name: 'Smoothie D√©tox', description: '√âpinards, pomme, concombre, citron', price: 5.50, category: 'Boisson', image: 'ü•§' }
      ]
    }
  ],
  orders: [],
  orderCounter: 1000
};

// Middlewares d'authentification
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token d\'acc√®s requis' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Token invalide' });
    }
    req.user = user;
    next();
  });
};

// Middleware pour l'authentification restaurant
const authenticateRestaurant = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Token d\'acc√®s requis' });
  }

  jwt.verify(token, JWT_SECRET, (err, restaurant) => {
    if (err) {
      return res.status(403).json({ error: 'Token invalide' });
    }
    if (!restaurant.restaurantId) {
      return res.status(403).json({ error: 'Token restaurant invalide' });
    }
    req.restaurant = restaurant;
    next();
  });
};

// ============================================
// ROUTES √âTUDIANTS (existantes)
// ============================================

app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, name, campus, year } = req.body;

    const existingUser = db.users.find(user => user.email === email);
    if (existingUser) {
      return res.status(400).json({ error: 'Cet email est d√©j√† utilis√©' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const newUser = {
      id: db.users.length + 1,
      email,
      password: hashedPassword,
      name,
      campus,
      year,
      loyaltyPoints: 0,
      totalOrders: 0,
      createdAt: new Date()
    };

    db.users.push(newUser);

    const token = jwt.sign(
      { userId: newUser.id, email: newUser.email },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.status(201).json({
      message: 'Compte cr√©√© avec succ√®s',
      token,
      user: {
        id: newUser.id,
        email: newUser.email,
        name: newUser.name,
        campus: newUser.campus,
        year: newUser.year,
        loyaltyPoints: newUser.loyaltyPoints
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la cr√©ation du compte' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = db.users.find(u => u.email === email);
    if (!user) {
      return res.status(400).json({ error: 'Email ou mot de passe incorrect' });
    }

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(400).json({ error: 'Email ou mot de passe incorrect' });
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.json({
      message: 'Connexion r√©ussie',
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        campus: user.campus,
        year: user.year,
        loyaltyPoints: user.loyaltyPoints,
        totalOrders: user.totalOrders
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la connexion' });
  }
});

app.get('/api/restaurants', (req, res) => {
  try {
    const restaurants = db.restaurants.map(restaurant => ({
      id: restaurant.id,
      name: restaurant.name,
      description: restaurant.description,
      image: restaurant.image,
      rating: restaurant.rating,
      prepTime: restaurant.prepTime,
      isOpen: restaurant.isOpen
    }));

    res.json({ restaurants });
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des restaurants' });
  }
});

app.get('/api/restaurants/:id/menu', (req, res) => {
  try {
    const restaurantId = parseInt(req.params.id);
    const restaurant = db.restaurants.find(r => r.id === restaurantId);

    if (!restaurant) {
      return res.status(404).json({ error: 'Restaurant non trouv√©' });
    }

    res.json({ menu: restaurant.menu });
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration du menu' });
  }
});

app.post('/api/orders', authenticateToken, async (req, res) => {
  try {
    const { restaurantId, items, paymentMethod, specialInstructions } = req.body;
    const userId = req.user.userId;

    const restaurant = db.restaurants.find(r => r.id === restaurantId);
    if (!restaurant) {
      return res.status(404).json({ error: 'Restaurant non trouv√©' });
    }

    const user = db.users.find(u => u.id === userId);
    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    let total = 0;
    const orderItems = [];

    for (const item of items) {
      const menuItem = restaurant.menu.find(m => m.id === item.id);
      if (!menuItem) {
        return res.status(400).json({ error: `Article non trouv√©: ${item.id}` });
      }

      orderItems.push({
        id: menuItem.id,
        name: menuItem.name,
        price: menuItem.price,
        quantity: item.quantity || 1,
        customizations: item.customizations || []
      });

      total += menuItem.price * (item.quantity || 1);
    }

    const order = {
      id: ++db.orderCounter,
      userId,
      restaurantId,
      restaurant: {
        id: restaurant.id,
        name: restaurant.name,
        image: restaurant.image
      },
      student: {
        id: user.id,
        name: user.name,
        email: user.email
      },
      items: orderItems,
      total,
      paymentMethod,
      paymentStatus: paymentMethod === 'card' ? 'paid' : 'pending',
      specialInstructions: specialInstructions || '',
      status: 'pending',
      estimatedTime: 10,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // G√©n√©rer le QR code
    const qrData = {
      orderId: order.id,
      userId: userId,
      restaurantId: restaurantId,
      total: total,
      timestamp: new Date().toISOString()
    };

    const qrCodeUrl = await QRCode.toDataURL(JSON.stringify(qrData));
    order.qrCode = qrCodeUrl;

    db.orders.push(order);

    // Mettre √† jour les points de fid√©lit√©
    user.loyaltyPoints += Math.floor(total);
    user.totalOrders += 1;

    // Simulation de progression automatique (optionnel pour d√©mo)
    // setTimeout(() => {
    //   const orderIndex = db.orders.findIndex(o => o.id === order.id);
    //   if (orderIndex !== -1 && db.orders[orderIndex].status === 'pending') {
    //     db.orders[orderIndex].status = 'preparing';
    //     db.orders[orderIndex].updatedAt = new Date();
    //   }
    // }, 30000); // 30 secondes

    res.status(201).json({
      message: 'Commande cr√©√©e avec succ√®s',
      order: {
        id: order.id,
        restaurant: order.restaurant,
        items: order.items,
        total: order.total,
        status: order.status,
        estimatedTime: order.estimatedTime,
        qrCode: order.qrCode,
        createdAt: order.createdAt
      }
    });
  } catch (error) {
    console.error('Erreur cr√©ation commande:', error);
    res.status(500).json({ error: 'Erreur lors de la cr√©ation de la commande' });
  }
});

app.get('/api/orders', authenticateToken, (req, res) => {
  try {
    const userId = req.user.userId;
    const userOrders = db.orders
      .filter(order => order.userId === userId)
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    res.json({ orders: userOrders });
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des commandes' });
  }
});

app.get('/api/profile', authenticateToken, (req, res) => {
  try {
    const userId = req.user.userId;
    const user = db.users.find(u => u.id === userId);
    
    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    res.json({
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        campus: user.campus,
        year: user.year,
        loyaltyPoints: user.loyaltyPoints,
        totalOrders: user.totalOrders
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration du profil' });
  }
});

// ============================================
// NOUVELLES ROUTES RESTAURANT
// ============================================

// Connexion restaurant
app.post('/api/restaurant/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    console.log('üîê === D√âBUT CONNEXION RESTAURANT ===');
    console.log('üìß Tentative de connexion:', email);

    const restaurant = db.restaurants.find(r => r.email === email);
    if (!restaurant) {
      console.log('‚ùå Restaurant non trouv√© avec email:', email);
      return res.status(400).json({ error: 'Email ou mot de passe incorrect' });
    }

    console.log('‚úÖ Restaurant trouv√©:', restaurant.name);
    console.log('üîê Hash stock√©:', restaurant.password);

    const isValidPassword = await bcrypt.compare(password, restaurant.password);
    console.log('üîç R√©sultat bcrypt.compare:', isValidPassword);

    if (!isValidPassword) {
      console.log('‚ùå Mot de passe incorrect pour:', email);
      return res.status(400).json({ error: 'Email ou mot de passe incorrect' });
    }

    const token = jwt.sign(
      { 
        restaurantId: restaurant.id, 
        email: restaurant.email,
        name: restaurant.name
      },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    console.log('‚úÖ Connexion restaurant r√©ussie:', restaurant.name);
    console.log('üîê === FIN CONNEXION RESTAURANT ===');

    res.json({
      message: 'Connexion restaurant r√©ussie',
      token,
      restaurant: {
        id: restaurant.id,
        email: restaurant.email,
        name: restaurant.name,
        description: restaurant.description,
        image: restaurant.image,
        rating: restaurant.rating,
        isOpen: restaurant.isOpen
      }
    });
  } catch (error) {
    console.error('‚ùå Erreur connexion restaurant:', error);
    res.status(500).json({ error: 'Erreur lors de la connexion' });
  }
});

// Profil restaurant
app.get('/api/restaurant/profile', authenticateRestaurant, (req, res) => {
  try {
    const restaurantId = req.restaurant.restaurantId;
    const restaurant = db.restaurants.find(r => r.id === restaurantId);
    
    if (!restaurant) {
      return res.status(404).json({ error: 'Restaurant non trouv√©' });
    }

    // Calculer les statistiques
    const restaurantOrders = db.orders.filter(order => order.restaurantId === restaurantId);
    const todayOrders = restaurantOrders.filter(order => {
      const orderDate = new Date(order.createdAt);
      const today = new Date();
      return orderDate.toDateString() === today.toDateString();
    });

    const todayRevenue = todayOrders
      .filter(order => order.paymentStatus === 'paid')
      .reduce((sum, order) => sum + order.total, 0);

    res.json({
      restaurant: {
        id: restaurant.id,
        name: restaurant.name,
        email: restaurant.email,
        description: restaurant.description,
        image: restaurant.image,
        rating: restaurant.rating,
        isOpen: restaurant.isOpen,
        stats: {
          todayOrders: todayOrders.length,
          todayRevenue: todayRevenue,
          totalOrders: restaurantOrders.length
        }
      }
    });
  } catch (error) {
    console.error('Erreur profil restaurant:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration du profil' });
  }
});

// R√©cup√©rer les commandes du restaurant
app.get('/api/restaurant/orders', authenticateRestaurant, (req, res) => {
  try {
    const restaurantId = req.restaurant.restaurantId;
    
    console.log('üìã R√©cup√©ration commandes pour restaurant:', restaurantId);
    
    const restaurantOrders = db.orders
      .filter(order => order.restaurantId === restaurantId)
      .filter(order => order.status !== 'completed') // Exclure les commandes termin√©es
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    console.log(`üì¶ ${restaurantOrders.length} commandes trouv√©es`);

    res.json({ 
      orders: restaurantOrders,
      total: restaurantOrders.length
    });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration commandes restaurant:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des commandes' });
  }
});

// Mettre √† jour le statut d'une commande
app.put('/api/restaurant/orders/:id/status', authenticateRestaurant, (req, res) => {
  try {
    const orderId = parseInt(req.params.id);
    const { status } = req.body;
    const restaurantId = req.restaurant.restaurantId;

    console.log(`üîÑ Mise √† jour statut commande ${orderId} vers ${status}`);

    const orderIndex = db.orders.findIndex(order => 
      order.id === orderId && order.restaurantId === restaurantId
    );

    if (orderIndex === -1) {
      return res.status(404).json({ error: 'Commande non trouv√©e' });
    }

    const validStatuses = ['pending', 'preparing', 'ready', 'completed', 'rejected'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ error: 'Statut invalide' });
    }

    // Mettre √† jour le statut
    db.orders[orderIndex].status = status;
    db.orders[orderIndex].updatedAt = new Date();

    // Si la commande passe en "ready", calculer le temps de pr√©paration r√©el
    if (status === 'ready') {
      const order = db.orders[orderIndex];
      const prepTime = Math.round((new Date() - new Date(order.createdAt)) / (1000 * 60));
      order.actualPrepTime = prepTime;
    }

    console.log(`‚úÖ Commande ${orderId} mise √† jour vers ${status}`);

    res.json({
      message: `Commande mise √† jour vers ${status}`,
      order: db.orders[orderIndex]
    });
  } catch (error) {
    console.error('‚ùå Erreur mise √† jour statut:', error);
    res.status(500).json({ error: 'Erreur lors de la mise √† jour du statut' });
  }
});

// Scanner et valider un QR code
app.post('/api/restaurant/orders/scan', authenticateRestaurant, (req, res) => {
  try {
    const { qrCode } = req.body;
    const restaurantId = req.restaurant.restaurantId;

    console.log('üì± Scan QR Code par restaurant:', restaurantId);

    if (!qrCode) {
      return res.status(400).json({ error: 'QR Code requis' });
    }

    let qrData;
    try {
      // Le QR code contient les donn√©es JSON de la commande
      qrData = JSON.parse(qrCode);
    } catch (e) {
      return res.status(400).json({ 
        success: false, 
        error: 'QR Code invalide - format incorrect' 
      });
    }

    // V√©rifier que le QR code contient les bonnes donn√©es
    if (!qrData.orderId) {
      return res.status(400).json({ 
        success: false, 
        error: 'QR Code invalide - donn√©es manquantes' 
      });
    }

    // Trouver la commande
    const orderIndex = db.orders.findIndex(order => 
      order.id === qrData.orderId && 
      order.restaurantId === restaurantId
    );

    if (orderIndex === -1) {
      return res.status(404).json({ 
        success: false, 
        error: 'Commande non trouv√©e ou non autoris√©e' 
      });
    }

    const order = db.orders[orderIndex];

    // V√©rifier le statut de la commande
    if (order.status !== 'ready') {
      return res.status(400).json({ 
        success: false, 
        error: `Commande non pr√™te (statut: ${order.status})` 
      });
    }

    // V√©rifier si d√©j√† r√©cup√©r√©e
    if (order.status === 'completed') {
      return res.status(400).json({ 
        success: false, 
        error: 'Commande d√©j√† r√©cup√©r√©e' 
      });
    }

    // Marquer comme termin√©e
    db.orders[orderIndex].status = 'completed';
    db.orders[orderIndex].completedAt = new Date();
    db.orders[orderIndex].updatedAt = new Date();

    console.log(`‚úÖ Commande ${order.id} r√©cup√©r√©e avec succ√®s`);

    res.json({
      success: true,
      message: 'QR Code valid√© avec succ√®s',
      order: {
        id: order.id,
        student: order.student,
        items: order.items,
        total: order.total,
        status: 'completed'
      }
    });
  } catch (error) {
    console.error('‚ùå Erreur scan QR:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur lors de la validation du QR Code' 
    });
  }
});

// Statistiques restaurant
app.get('/api/restaurant/stats', authenticateRestaurant, (req, res) => {
  try {
    const restaurantId = req.restaurant.restaurantId;
    const restaurantOrders = db.orders.filter(order => order.restaurantId === restaurantId);
    
    // Statistiques aujourd'hui
    const today = new Date();
    const todayOrders = restaurantOrders.filter(order => {
      const orderDate = new Date(order.createdAt);
      return orderDate.toDateString() === today.toDateString();
    });

    // Revenus du jour
    const todayRevenue = todayOrders
      .filter(order => order.paymentStatus === 'paid')
      .reduce((sum, order) => sum + order.total, 0);

    // Plats populaires
    const itemCounts = {};
    restaurantOrders.forEach(order => {
      order.items.forEach(item => {
        itemCounts[item.name] = (itemCounts[item.name] || 0) + item.quantity;
      });
    });

    const popularItems = Object.entries(itemCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([name, count]) => ({ name, count }));

    // Temps de pr√©paration moyen
    const completedOrders = restaurantOrders.filter(order => order.actualPrepTime);
    const avgPrepTime = completedOrders.length > 0 
      ? Math.round(completedOrders.reduce((sum, order) => sum + order.actualPrepTime, 0) / completedOrders.length)
      : 0;

    res.json({
      today: {
        orders: todayOrders.length,
        revenue: todayRevenue,
        pending: todayOrders.filter(o => o.status === 'pending').length,
        preparing: todayOrders.filter(o => o.status === 'preparing').length,
        ready: todayOrders.filter(o => o.status === 'ready').length,
        completed: todayOrders.filter(o => o.status === 'completed').length
      },
      total: {
        orders: restaurantOrders.length,
        revenue: restaurantOrders.filter(o => o.paymentStatus === 'paid').reduce((sum, o) => sum + o.total, 0)
      },
      popularItems,
      avgPrepTime
    });
  } catch (error) {
    console.error('‚ùå Erreur statistiques restaurant:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des statistiques' });
  }
});

// ============================================
// ROUTES COMMUNES
// ============================================

app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    message: 'CampusEats API is running on Render!',
    timestamp: new Date().toISOString(),
    version: '1.1.0 - HASH CORRIG√â',
    endpoints: {
      student: ['auth', 'restaurants', 'orders', 'profile'],
      restaurant: ['auth/login', 'orders', 'scan', 'stats']
    },
    debug: {
      restaurantCredentials: [
        'pizzeria@campus.fr / password123',
        'green@campus.fr / password123'
      ]
    }
  });
});

app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route non trouv√©e' });
});

app.listen(PORT, '0.0.0.0', async () => {
  console.log(`üöÄ CampusEats API d√©marr√©e sur le port ${PORT}`);
  console.log(`üåê Pr√™t √† servir les √©tudiants du campus!`);
  console.log(`üè™ Dashboard restaurant disponible!`);
  console.log(`üìä Comptes restaurant de test:`);
  console.log(`   - pizzeria@campus.fr / password123`);
  console.log(`   - green@campus.fr / password123`);
  
  // V√©rification automatique du hash au d√©marrage
  console.log('\nüîê === V√âRIFICATION HASH AU D√âMARRAGE ===');
  try {
    const testPassword = 'password123';
    const correctHash = '$2b$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi';
    
    const isValid = await bcrypt.compare(testPassword, correctHash);
    console.log(`‚úÖ Test hash pour "${testPassword}": ${isValid ? 'VALIDE' : 'INVALIDE'}`);
    
    // Test avec les restaurants de la DB
    for (const restaurant of db.restaurants) {
      const restaurantTest = await bcrypt.compare(testPassword, restaurant.password);
      console.log(`üè™ ${restaurant.name} (${restaurant.email}): ${restaurantTest ? '‚úÖ OK' : '‚ùå ERREUR'}`);
    }
  } catch (error) {
    console.error('‚ùå Erreur v√©rification hash:', error);
  }
  console.log('üîê === FIN V√âRIFICATION ===\n');
});

module.exports = app;
